/*
  Wireless PIR sensor firmware
  revision 1.0
 
  Copyright (c) 2014, Andrey Shigapov, All rights reserved
 
  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  http://www.gnu.org/licenses/gpl.txt
  
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
  
*/

/////////////////////////////////////////////////////////////////////////////////////////////
// This program puts MCU in sleep mode and uses two interrupts to process events in order to save energy
// The first interrupt is generated by PIR sensor output connected to D2 input, the interrupt handler schedules 
// transmission of a single byte command with ASCII value of 'o' and disables PIR sensor for a number of WDT interrupts
// The second interrupt is generated by WDT and it fires about every 8 sec. 
// This interrupt handler decreases PIR sensor disable counter
/////////////////////////////////////////////////////////////////////////////////////////////

#include <avr/sleep.h>
#include <avr/power.h>
#include <SPI.h>
#include "nRF24L01.h"
#include "RF24.h"

//#define ENABLE_SERIAL 
#define PIR_DISABLE_INTERVAL 4

int led = A4;         // the pin that the LED is attached to
int buzzer = 5;       // the pin that the Buzzer is attached to
int PIR_enable = 6;   // the pin that controls PIR output
int PIR_input = 2;    // the pin that connected to PIT output

int ledRx = led;
int ledTx = led;

unsigned int pir_disable_counter = 0;
unsigned int pir_enable_counter = 0;


// Set up nRF24L01 radio on SPI bus plus pins 9 & 10 
RF24 radio(9,10);

// Radio pipe addresses for the 2 nodes to communicate.
const uint64_t pipes[2] = { 0xE7E7E7E700LL, 0xE7E7E7E700LL }; // !!! DO NOT THIS COMMIT VALUE !!!

char dataToSend = 'z';
char dataRecv = 'z';

void openPipes()
{
    uint64_t txPipe = pipes[0];
    uint64_t rxPipe = pipes[1];

    radio.openWritingPipe(txPipe);
    radio.openReadingPipe(1, rxPipe);
}


/////////////////////////////////////////////////////////////////
//  Returns:     Nothing.
//  Parameters:  None.
//
//  Description: PIR output signal Interrupt Service. 
//               This is executed when PIR sensor sense a movement,
//               it disables the PIR sensor for several WDT intervals
//               in order to conserve the energy
/////////////////////////////////////////////////////////////////
void processPIR()
{
  if(pir_disable_counter == pir_enable_counter) {
    pir_disable_counter += PIR_DISABLE_INTERVAL;
    dataToSend = 'o';
    dataRecv = 'z';
  }
}


/////////////////////////////////////////////////////////////////
//  Returns:     Nothing.
//  Parameters:  None.
//
//  Description: Watchdog Interrupt Service. This
//               is executed when watchdog timed out, 
//               approximately every 8 seconds
/////////////////////////////////////////////////////////////////
ISR(WDT_vect)
{
  if(pir_disable_counter != pir_enable_counter) {
    pir_enable_counter += 1;
  }
}


/////////////////////////////////////////////////////////////////
//  Returns:     Nothing.
//  Parameters:  None.
//
//  Description: Enters the arduino into sleep mode.
/////////////////////////////////////////////////////////////////
void enterSleep(void)
{
  set_sleep_mode(SLEEP_MODE_PWR_DOWN);   /* EDIT: could also use SLEEP_MODE_PWR_DOWN for lowest power consumption. */
  sleep_enable();
  
  //turn off peripherals
  ADCSRA = 0;
  PRR = 0
      | (1<<PRTWI)     // turn off TWI
      | (1<<PRTIM0)    // turn off Timer/Counter0
      | (1<<PRTIM1)    // turn off Timer/Counter1 (leave Timer/Counter2 on)
      | (1<<PRSPI)     // turn off SPI
      | (1<<PRUSART0)  // turn off USART (will turn on again when reset)
      | (1<<PRADC)     // turn off ADC
      | 0;


  //shut off BOD:
  MCUCR = _BV (BODS) | _BV (BODSE);  // turn on brown-out enable select
  MCUCR = _BV (BODS);        // this must be done within 4 clock cycles of above

  
  // Now enter sleep mode.
  sleep_cpu();
  
  // The program will continue from here after the WDT timeout
  // First thing to do is disable sleep.
  sleep_disable(); 
  
  // Re-enable the peripherals.
  power_all_enable();
  ADCSRA = 1;
  PRR = 0
#ifndef ENABLE_SERIAL
      | (1<<PRUSART0)  // turn off USART
#endif //#ifndef ENABLE_SERIAL
      | 0;
}


// the setup routine runs once when you press reset:
void setup()  { 
  
#ifdef ENABLE_SERIAL
  Serial.begin(57600);
  Serial.println("");
  Serial.println("=====================================");
  Serial.println("PIR sensor");
  Serial.println("=====================================");
#endif //#ifdef ENABLE_SERIAL
  
  // declare pin 9 to be an output:
  pinMode(led, OUTPUT);
  pinMode(buzzer, OUTPUT);
  pinMode(PIR_input, INPUT);
  pinMode(PIR_enable, OUTPUT);
  digitalWrite(PIR_enable, 1);
  
  //
  // Setup and configure rf radio
  //
  radio.begin();

  // set output level
  radio.setPALevel(RF24_PA_MIN);
  
  // optionally, increase the delay between retries & # of retries
  radio.setRetries(15, 5);
  radio.setAutoAck(true);
  
  // set CRC to 8 bit
  radio.setCRCLength(RF24_CRC_8);
  
  // set data rate to 250 Kbps
  radio.setDataRate(RF24_250KBPS);
  
  // set channel 15
  radio.setChannel(15);

  // optionally, reduce the payload size.  seems to
  // improve reliability
  radio.setPayloadSize(1);

  //
  // Dump the configuration of the rf unit for debugging
  //
  radio.printDetails();
  
  //
  // Open pipes to other nodes for communication
  //
  openPipes();
  
  //////////////////////////////////////////////////////////////////////////
  //     Setup the WDT interrupt
  //////////////////////////////////////////////////////////////////////////
  // Clear the reset flag.
  MCUSR &= ~(1<<WDRF);
  
  // In order to change WDE or the prescaler, we need to
  // set WDCE (This will allow updates for 4 clock cycles).
  WDTCSR |= (1<<WDCE) | (1<<WDE);

  // set new watchdog timeout prescaler value
  WDTCSR = 1<<WDP0 | 1<<WDP3; // 8.0 seconds 
  
  // Enable the WD interrupt (note no reset).
  WDTCSR |= _BV(WDIE);
  
  
  //////////////////////////////////////////////////////////////////////////
  //     Setup PIR interrupts
  //////////////////////////////////////////////////////////////////////////
  attachInterrupt(0, processPIR, FALLING);
//  attachInterrupt(1, processPIR, RISING);
} 

// the loop routine runs over and over again forever:
void loop()  { 

  if (dataToSend != dataRecv)  {
#ifdef ENABLE_SERIAL
    Serial.println("send a signal");
#endif //#ifdef ENABLE_SERIAL

    //power up the radio first    
    radio.powerUp();

    // First, stop listening so we can talk.
    radio.stopListening();
    delay(10);
    
    // Take the time, and send it.  This will block until complete
    digitalWrite(ledTx, HIGH);   
    delay(50);
    bool ok = radio.write( &dataToSend, sizeof(dataToSend) );
    digitalWrite(ledTx, LOW);
    
    // Now, continue listening
    unsigned long started_waiting_at = millis();
    delay(10);
    radio.startListening();
   
    if(!ok) {
      // blink LED several times in case of transmission error
      digitalWrite(ledTx, HIGH);
      delay(50);
      digitalWrite(ledTx, LOW);
      delay(30);
      digitalWrite(ledTx, HIGH);
      delay(50);
      digitalWrite(ledTx, LOW);
      delay(30);
      digitalWrite(ledTx, HIGH);
      delay(50);
      digitalWrite(ledTx, LOW);
    }
    
    radio.stopListening();
    delay(200);  
    radio.powerDown();
    
    dataToSend = dataRecv = 'z';
    
  } else {
#ifdef ENABLE_SERIAL
    Serial.println("go to sleep");
    delay(100);
#endif //#ifdef ENABLE_SERIAL
    // set sleep mode
    enterSleep();

    //enable/disable PIR
    digitalWrite(PIR_enable, (pir_disable_counter == pir_enable_counter)?1:0);
  }
    
}

